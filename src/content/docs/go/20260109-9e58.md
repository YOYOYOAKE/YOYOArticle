---
title: 'Part 6 Go 错误处理'
description: '本节包括 Go 的 error 和 panic 等内容。'
category: 'go'
createTime: 2026-01-09
lastEditedTime: 2026-01-12 08:27:00
completed: true
top: false
tags: ['Go']
---

## 1 error


### 1.1 显式返回错误


Go **显式返回**并**强制处理错误**，而非传统的 `try-catch` 异常处理机制。对于其他语言来说，错误是一种**特殊事件**。当错误发生时，程序控制流会发生跳跃直至遇到 `catch` 块。而在 Go 语言中，错误只是一个普通的**值**，需要显式地用代码去判断和处理。


Go 的标准库定义了一个 `error` 接口，表示对错误的抽象。任何实现了 `Error()` 方法的类型都可以作为错误。


```go
type error interface {
    Error() string
}
```


Go 提供了 `errors` 包来生成错误信息。在 Go 中，错误通常作为函数的最后一个返回值返回，开发者需要显式检查并处理：


```go
func mySqrt(f float64) (float64, error) {
	if f < 0 {
		return 0, errors.New("math: square root of negative number")
	}

	return math.Sqrt(f), nil
}
```


例如，在 `mySqrt()` 函数中，当我们传入一个负数时，第二个返回值就会返回错误。我们需要在函数外部判断函数中是否存在错误：


```go
func main() {
		result, err := mySqrt(-4)
		if err != nil {
				fmt.Println("Error:", err)
		} else {
				fmt.Println("Square root:", result)
		}
}
```


### 1.2 错误包装


Go 的错误的值是一个字符串，自然就可被 fmt 包来处理。对于错误，fmt 包专门提供了一个 fmt.Errorf() 函数用于创建或包装错误：


```go
baseErr := errors.New("数据库连接断开")
err1 := fmt.Errorf("查询失败: %v", baseErr)
```


但是这种情况有一个显而易见的缺点，就是 `%v` 占位符。`%v` 占位符仅仅把原来的错误**转成字符串**拼接到新错误里，原来的错误对象消失了，只剩下文本。


为了解决错误对象消失（错误链断开）的情况，Go 在 1.13 版本引入了 %w 占位符，专门用于错误包装：


```go
err2 := fmt.Errorf("查询失败: %w", baseErr)
```


`%w` 占位符不仅保留错误文本，还将原始错误对象**嵌入**到新错误中，避免了错误链断开。我们可以使用 `error.Is` 来验证。


### 1.3 错误链处理


Go 1.13 引入了 `errors.Is` 和 `errors.As` 用于处理错误链。


#### **1.3.1 errors.Is**


`error.Is` 用于检查某个错误是否为**特定错误**或是**由该错误包装而成**。对于上边的例子来说，要验证 `baseErr` `err1` `err2` 的关系，只需要使用 `error.Is` 判断一下就行了：


```go
fmt.Println(errors.Is(err1, baseErr)) // false
fmt.Println(errors.Is(err2, baseErr)) // true
```


这说明，`err1` 确实是一个全新的错误，它和原本的 `baseErr` 不相同。而 `err2` 尽管经过了包装，但是仍然保留了原始的错误信息。


#### **1.3.2 errors.As**


`error.As` 用于检查错误链中是否存在某种**特定类型**的错误，并将错误转换为特定类型以便进一步处理，就像类型断言。


首先我们先创建并包装一个错误：


```go
_, err := os.Open("non-existing.txt")
wrappedErr := fmt.Errorf("操作失败: %w", err)
```


然后定义一个指针变量用来接收解包出来的错误：


```go
var pathErr *os.PathError
```


然后使用 `error.As` 检查：


```go
if errors.As(wrappedErr, &pathErr) {
		fmt.Println("error.As: 捕捉到了路径错误！")
		fmt.Println("错误发生的文件路径是:", pathErr.Path)
		fmt.Println("具体操作是:", pathErr.Op)
} else {
			fmt.Println("不是 PathError 类型")
		}
}
```


如果 `wrappedErr` 包含 `pathErr` 类型（在这里是 `os.PathError` 类型）的错误，就会将发生的错误 `wrappedErr` 转换为 `os.PathError` 进行处理。


```
error.As: 捕捉到了路径错误！
错误发生的文件路径是: non-existing.txt
具体操作是: open
```


> [!caution] `error.As` 的第二个参数
> 在使用 `error.As` 时，第二个参数必须是指向接口或实现了 `erro`r 接口类型的指针。
>
>
> 当没有传指针时，如 `errors.As(err, myErr)`，Go 编译器可能会报错。正确写法应该为 `errors.As(err, &myErr)`。


### 1.4 errors.Join


errors.Join 是 Go 在 1.20 引入的一个新特性，它允许你把多个错误打包成一个切片。在此之前，Go 的错误包装是一层层的嵌套结构。而现在，你可以将多个独立的错误合并为一个错误对象返回：


```go
err1 := errors.New("用户名不能为空")
err2 := errors.New("密码长度不足")
combinedErr := errors.Join(err1, err2)

fmt.Println(combinedErr)
```


同时，合并后的错误对象不影响 `errors.Is` 的检查：


```go
if errors.Is(combinedErr, err1) {
    fmt.Println("用户未填写用户名")
}

if errors.Is(combinedE, err2) {
    fmt.Println("发现错误二！")
}
```


## 2 panic


除了 error外，Go 还有 panic 用于处理不可恢复的错误。


我们以一个简单的例子介绍。


```go
func safeFunction() {
		defer func() {
				if r := recover(); r != nil {
		        fmt.Println("Recovered from panic:", r)
        }
    }()
    panic("something went wrong")
}

func main() {
    fmt.Println("Starting program...")
    safeFunction()
    fmt.Println("Program continued after panic")
}
```


在这个例子中出现了三个关键字 `panic` `recover` `defer`。这三个字通常是一起出现的：

- `panic`：相当于 `throw Exception`。它表示发生了无法继续运行的错误。一旦触发，当前函数立即停止，开始执行 defer 栈；
- `defer`：相当于 `finally` 块。不管函数是否出错，它都会在函数结束前运行。 `recover` 必须放在 `defer` 里面才有效。如果你在正常代码里写 `recover()`，它什么也抓不到；
- `recover`：相当于 `catch` 块。它只能在 `defer` 中被调用。如果程序正在 panic，它会捕获 panic 的值并恢复正常执行；如果程序正常，它返回 `nil`。

这段代码的运行过程是这样的：

1. `main` 函数启动：

    打印 `"Starting program..."`；

2. 调用 `safeFunction()`：
    1. 进入函数内部；
    2. 注册 `defer`：告诉 Go 运行时，“不管这函数怎么结束（正常返回还是炸了），退出前一定要执行这个匿名函数”；
    3. 触发 `panic`：程序执行到 `panic("something went wrong")`；
        - 此时，`safeFunction` 的**正常执行流程立即停止**（panic 下面的代码不会被执行）；
        - 程序开始“向上冒泡”，准备崩溃退出；
3. `defer` 拦截：
    1. 在崩溃发生、函数即将退出的一瞬间，之前注册的 `defer` 函数被激活；
    2. `recover()`：捕捉到了正在发生的 panic。它把 panic 的值（`"something went wrong"`）赋值给 `r`，并**停止了程序的崩溃过程**；
    3. 打印 `"Recovered from panic: something went wrong"`；
4. 返回 `main`：

    因为 panic 被 recover 拦截了，`safeFunction` 被视为“正常返回”（虽然没有返回值）。`main` 函数继续执行 `safeFunction()` 后面的代码；

5. 程序继续：

    打印 `"Program continued after panic"`。


> [!tip] `defer` 中的错误处理
> 在 Go 1.20 之前，如果在 `defer` 中关闭文件出错，我们通常很难把这个错误优雅地返回给调用者（因为要在 return 之后才执行 defer）。
>
>
> 现在我们可以用 errors.Join 来做：
>
>
> ```go
> func copyFile(src, dst string) (err error) {
>     f, _ := os.Open(src)
>
>     // 退出时关闭文件
>     defer func() {
>         // 如果关闭文件时报错，把它加入到现有的 err 中
>         // 这样既保留了业务逻辑的错误，也保留了关闭文件的错误
>         err = errors.Join(err, f.Close())
>     }()
>
>     // ... 业务逻辑 ...
>     return nil
> }
> ```
