---
title: 'A7 核心：并发'
description: '本节包括 Go 的协程、通道和流程控制等内容。'
category: 'go'
createTime: 2026-01-13
lastEditedTime: 2026-01-13 10:10:00
completed: true
top: false
tags: ['Go']
---

Go 语言之所以在后端开发中如此流行，很大程度上归功于其**原生支持、轻量级且高效**的并发模型。


Go 的并发设计哲学可以总结为一句名言：**不要通过共享内存来通信，而要通过通信来共享内存。**_**（Do not communicate by sharing memory; instead, share memory by communicating.）**_


## 1 协程


协程（**Goroutine**）是 Go 管理的轻量级线程，是 Go 中的并发执行单位。启动一个协程只需要 KB 级的内存，且栈大小可以动态伸缩。


要启动一个协程，只需要在函数调用前加上 `go` 关键字。


```go
func main() {
    go doSomething()
    // existing code
}
```


下面这个小案例将体现协程的特点：


```go
func main() {
		var wg sync.WaitGroup

		fmt.Println("开始任务")

		// 启动 3 个协程
		for i := 1; i <= 3; i++ {
				wg.Add(1) // 计数器 +1
				go func(id int) {
						defer wg.Done() // 函数结束时，计数器 -1
			
						// 模拟耗时任务
						fmt.Printf("协程 %d: 正在工作...\n", id)
						time.Sleep(time.Second) 
						fmt.Printf("协程 %d: 完成!\n", id)
				}(i)
		}

		wg.Wait()
		fmt.Println("所有任务已完成")
}
```


在这个案例中，我们一共启动了三个并行任务。运行后的输出应该是这样的：


```
开始任务
协程 1: 正在工作...
协程 3: 正在工作...
协程 2: 正在工作...
协程 2: 完成!
协程 1: 完成!
协程 3: 完成!
所有任务已完成
```


多次运行，你会发现这三个任务的启动和完成顺序并不一直相同。这正说明了它们三个是并行运行的。


> [!note] `sync.WaitGroup`
> 因为没有通道来通知主线程任务何时结束，所以必须使用 `sync.WaitGroup` 来防止主线程在协程执行完之前就退出了。
>
>
> `wg.Add(1)` 把 `wg` 里内部的计数器 +1，表示接下来会有 1 个任务需要等待完成。而每个协程结束时会调用 `wg.Done()`，把计数器 -1。当计数器变成 0 时，`wg.Wait()` 才会返回。
>
>
> sync 是 Go 提供的一个标准库，我们将在后续介绍。


## 2 通道


通道（**Channel**）用于 Goroutine 之间的数据传递，它保证了数据交换的安全性，避免了显式的锁操作。


通道可分为无缓冲的通道和有缓冲的通道：

- 无缓冲（**Unbuffered**）：同步通信。发送方发送数据后必须等待接收方接收，否则会阻塞；
- 有缓冲（**Buffered**）：异步通信。只要缓冲区未满，发送方就不会被阻塞。

通道也是一个变量，我们使用 `make()` 函数和 `chan` 关键字来声明：


```go
ch := make(chan int)
```


或者在第二个参数中指明缓冲区大小，否则将创建无缓冲的通道：


```go
ch := make(chan int, 100)
```


这样就创建了一个缓冲区大小为 100、且存储整型数据的通道。


要向通道中发送或接收数据，需要使用 `<-` 运算符。该运算符会把右侧的数据发送到左侧：


```go
func main() {
		ch := make(chan int, 3)

		// 发送数据
		ch <- 1
		ch <- 2

		// 接收数据
		val := <-ch
		fmt.Println("Received:", val) // Received: 1

		// 第二次接收数据
		val = <-ch
		fmt.Println("Received:", val) // Received: 2

		// 关闭通道
		close(ch)

		// 尝试接收关闭后的通道数据
		val = <-ch
		fmt.Println("Received:", val) // Received: 0
}
```


> [!warning] 警告
> 如果在没有协程的情况下使用无缓冲通道，会直接导致**死锁（Deadlock）**。


> [!tip] 关闭通道
> 使用 close() 函数关闭一个通道。当通道关闭后，继续接收会得到零值，但继续发送会引发 panic。


通道通常和协程一起使用。例如，使用协程和通道，与主线程一起实现生产者-消费者模型：

- 协程/生产者：负责生产数据并写入通道；
- 通道：负责传递数据，实现边生产边消费；
- 主线程/消费者：负责从通道接收并处理数据。

例如这个案例：


```go
func producer(ch chan<- string) {
		data := []string{"数据A", "数据B", "数据C"}

		for _, d := range data {
				fmt.Println("正在处理：", d)
				time.Sleep(500 * time.Millisecond)
				ch <- d
		}

		close(ch)
}

func main() {
		ch := make(chan string)
		go producer(ch)

		fmt.Println("开始处理数据")

		for d := range ch {
				fmt.Println("接收处理好的数据", d)
		}

		fmt.Println("所有数据已处理完毕")
}
```


在这里，我们启动了一个协程 `producer`，令其遍历数据并发送到通道中。而主线程则遍历通道，直到协程将所有任务处理完毕后关闭通道。


> [!tip] 单向通道
> 函数签名中 `ch chan<- string` 表示这个通道是一个单向通道，只能向其中写入数据。


为了更贴合实际场景，我们设计一个并发下载器：


```go
func download(file string, ch chan<- string, wg *sync.WaitGroup) {
		defer wg.Done()

		fmt.Printf("正在下载 %s ......\n", file)
		duration := time.Duration(rand.Intn(1000)) * time.Millisecond
		time.Sleep(duration)

		result := fmt.Sprintf("%s 下载完成，耗时 %v", file, duration)
		ch <- result
}

func main() {
		files := []string{"image.jpg", "movie.mp4", "data.csv", "game.exe", "report.pdf"}
		ch := make(chan string)
		var wg sync.WaitGroup

		fmt.Println("=== 开始并发下载 ===")

		for _, file := range files {
				wg.Add(1)
				go download(file, ch, &wg) 
		}

		go func() {
				wg.Wait()
				close(ch)
		}()

		for msg := range ch {
				fmt.Println(msg)
		}

		fmt.Println("=== 所有文件处理完毕 ===")
}
```


对比生产者-消费者和并发下载器这两个案例，你会发现后者并不是前者的扩展，而是一种新的设计。


在前一个案例中，我们只使用了一个协程去处理所有 `go productor(ch)` 数据。在协程内部，依然是**依次处理**数据。而在后边中这个案例中，我们使用循环创建了很多协程。每个协程都被分配到一个下载任务，然后**同时进行**。


这正是并发的核心。


同时还有一个有意思的小细节：


```go
go func() {
		wg.Wait()
		close(ch)
}()
```


这里的意思是创建一个立即执行函数并用协程启动。它的作用是，**在不阻塞主线程接收数据的情况下，安全地关闭通道。**


这个小协程的存在基于三个需求：

- 必须有人在读取数据（主线程）；
- 必须有人在等待任务结束（`wg.Wait`）;
- **读取和等待不能相互卡住**。

因此需要引入一个第三方的角色去管理通道的关闭。当全部任务结束后关闭通道，主线程发现通道关闭后结束运行。


如果不使用协程，那大概会有以下的错误写法：


```go
func main() {
    // ... 启动了 5 个协程 ...

    // 主线程会在这里卡住了
    wg.Wait()
    close(ch)

    // 主线程根本走不到这里，因为还在上面等待
    // 而协程里的数据发不过来（如果通道满了），导致死锁
    for msg := range ch {
        fmt.Println(msg)
    }
}
```


或者是：


```go
func main() {
    // ... 启动了 5 个协程 ...

    // 主线程陷入无限等待，因为通道没人关闭，循环会一直读取通道
    for msg := range ch {
        fmt.Println(msg)
    }
    
    // 代码永远走不到这里
    wg.Wait()
    close(ch)
}
```


## 3 Select 语句


变量可以接收来自多个通道的数据。既然有多个通道同时传递数据，自然就有快有慢。switch 关键字可以阻塞流程，直到某个分支可以运行：


```go
select {
case msg1 := <-ch1:
    fmt.Println("先收到通道1的数据:", msg1)
case msg2 := <-ch2:
    fmt.Println("先收到通道2的数据:", msg2)
}
```


`select` 语法很像 `switch`，但是专门用于通道。


如果你不想让它阻塞运行，就添加一个 `default` 分支。当所有通道都没有数据时，就会执行 `default` 分支。


在实际开发中，经常用于**超时控制**：


```go
func main() {
    ch := make(chan string)

    // 假设这个协程可能卡死，或者很慢
    go func() {
        time.Sleep(5 * time.Second)
        ch <- "任务完成"
    }()

    select {
    case res := <-ch:
        fmt.Println("收到结果:", res)
    case <-time.After(2 * time.Second): // 2秒后，这个通道会自动收到一个时间
        fmt.Println("任务超时")
    }
}
```


## 4 上下文


上下文**（Context）**是一个**接口**，用来控制协程的生命周期。


### **4.1 上下文树**


理解上下文的关键在于理解它是一个树状结构。上下文不会凭空产生，它必须由一个父节点衍生出来。


有两种方式创建根节点：

- `context.Background()`：通常作为整个程序或者一个 HTTP 请求的源头。它是空的，永远不会被取消。
- `context.TODO()`：当不确定用什么，或是代码还没写完时使用。实际上它和 `context.Background()` 作用一样，只是语义不同。

在根节点之上，有多种方式创建子节点，它们的作用各不相同：

- `context.WithCancel()`：手动取消；
- `context.WithTimeout()`：超时取消；
- `context.WithValue()`：携带数据。

每当创建一个子节点，这个字节点就会持有**对父节点的引用**。因此，如果父节点被取消，那么持有它的所有子节点、孙子节点都会收到**取消信号**。如果子节点被取消，则父节点不受影响。


### **4.2 上下文节点的创建**


`context.WithCancel()`用来创建一个能被手动取消的上下文节点，该方法会返回节点本身 `ctx` 和一个函数 `cancel()`。当后续代码执行 `cancel()` 时，该节点就会被取消。


```go
ctx, cancel := context.WithCancel(parentCtx)
// existing code
cancel()
```


`context.WithTimeout()`用来创建一个超时自动取消的上下文节点。当达到超时时间后，即使没有调用 ，该节点也会被取消。


```go
ctx, cancel := context.WithTimeout(parentCtx, 5*time.Second)
defer cancel() // 依然建议配合 defer 使用，提前释放资源
```


`context.WithValue()` 用来在调用链中传递键值对。


```go
ctx := context.WithValue(parentCtx, "TraceID", "12345")
id := ctx.Value("TraceID")
```


> [!tip] 在调用链中传递元数据
> 虽然 `context.WithValue()` 很好用，但是不要用它传递参数，只传递如 `UserID` `Token` `RequestID` 等元数据。
>
>
> 此外，**上下文节点是不可变的**。当调用 context.WithValue() 时，并没有修改旧的上下文节点，而是创建了一个新的。


### 4.3 上下文节点的取消


以下为标准范式：


```go
func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    go worker(ctx)
}

func worker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            err := ctx.Err() 
            fmt.Println("结束原因:", err) 
            return
            
        default:
            fmt.Println("工作中...")
            time.Sleep(500 * time.Millisecond)
        }
    }
}
```


在主线程中，我们创建了一个等待时长为 2 秒的上下文节点，并将该节点传入协程中。而在协程中，Select 语句监听了一个 `ctx.Done()` 的分支。当该分支被执行时，协程被停止。


ctx.Done() 本质上是一个空结构体通道（`chan struct{}`），因此不占用任何内存。正常状态下，通道打开且为空，协程就会被阻塞，只能执行 `default` 分支。


当执行 `cancel()` 时，通道被关闭。根据 Go 的语法规则，从一个已关闭的通道读取数据永远不会被阻塞，而是返回零值。因此，所有被 `case <-ctx.Done()` 阻塞的协程都会得到一个零值，然后执行该分支，执行 `return` 退出。


> [!important] 一些约定俗成的惯例
> - 上下文节点应该作为函数的**第一个参数**，并命名为 `ctx`;
> - **不要将上下文节点放在结构体里**，因为上下文是单次请求、随着调用栈传递的；
> - **总是调用** `cancel()`，即使是 `ctx.WithTimeout()`，也要 `defer cancel()`。
